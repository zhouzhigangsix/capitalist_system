# TDX API 更新说明（2025-11-10）

## 1. 新增 / 调整接口

### 1.1 全量历史 K 线
- `GET /api/kline-all/tdx`：返回通达信原始（不复权）历史 K 线，支持全部周期，响应结构：
  ```json
  {
    "code": 0,
    "message": "success",
    "data": {
      "count": 1000,
      "list": [ ... ],
      "meta": {
        "source": "tdx",
        "type": "day",
        "batch_limit": 800,
        "notes": [
          "通达信单次底层请求最多返回 800 条数据，服务端已顺序拼接全量结果",
          "对于上市时间较长的标的，请预估调用耗时（通常 1-5 秒），客户端需自行设置超时与兜底策略",
          "若实测请求在超时阈值内成功返回数据，即视为成功调用，无需按预设超时上限计入统计"
        ]
      }
    }
  }
  ```
- `GET /api/kline-all/ths`：返回同花顺前复权日/周/月 K 线，响应结构与上方一致，`meta.source="ths"`。

> 兼容性提示：旧版脚本若按数组解析需改为读取 `data.list`。

### 1.2 历史成交与交易日接口
- `GET /api/trade-history/full`：新增 `start_date` / `end_date` / `include_today` 参数，支持按交易日批量拉取，响应：
  ```json
  {
    "code": 0,
    "message": "success",
    "data": {
      "code": "000001",
      "start_date": "2024-10-01",
      "end_date": "2024-10-08",
      "limit": 300,
      "count": 300,
      "truncated": false,
      "covered_dates": ["20241001", "..."],
      "list": [ ... ]
    }
  }
  ```
- `GET /api/workday/range`：在交易日日志为空时自动触发 `manager.Workday.Update()` 并返回 `list` 数组。原本返回纯列表的调用需改为读取 `data.list`。

### 1.3 分时数据
- `GET /api/minute`：不再自动回退其他日期，如指定日期无数据返回 `List: []`，留给调用方自行兜底。响应字段保留 `date`。

### 1.4 任务接口
- `POST /api/tasks/pull-kline` / `POST /api/tasks/pull-trade`：保持原行为，新测试脚本会在测试结束后自动取消任务。

## 2. 前端改进
- `web/static/app.js`：
  - `switchTab(evt, tabName)` 使用 `requestAnimationFrame + resize()` 解决图表仅显示在左侧的问题。
  - `displayMinute` 与 `displayKline` 初次渲染后立即调用 `resize()`。
- `web/static/index.html`：更新标签按钮为 `onclick="switchTab(event, 'kline')"` 等写法。

## 3. 测试脚本
- 新增 `scripts/run_api_checks.py`，覆盖所有公开接口并兼容新响应格式，运行示例：
  ```bash
  python scripts/run_api_checks.py
  ```
- 新增 `scripts/test_tdx_all_api.py`，运行示例：
  ```bash
  python -I scripts/test_tdx_all_api.py \
    --base-url http://127.0.0.1:8080 \
    --verbose \
    --output tmp/tdx_api_test_results.json
  ```

## 4. 验证建议
1. 访问 `http://localhost:8080/static/app.js`，确认 `switchTab(evt, tabName)` 逻辑存在。
2. 浏览器强制刷新/清缓存，确保加载新脚本。
3. 完整运行两套测试：
   - `python run_api_checks.py`
   - `python -I scripts/test_tdx_all_api.py ...`
4. 若进一步部署到容器环境，确认 `docker logs -f tdx-stock-web` 输出健康检查成功。

---

# 附录：TDX 历史 K 线首次全量 + 增量更新示例

以下示例演示如何调用 `/api/kline-all/*` 与 `/api/kline-history` 接口，将单只股票的历史 K 线首次全量写库，并在后续运行中按增量补齐。若需前复权，可将全量接口改成 `/api/kline-all/ths`。

## 数据库建表

```sql
CREATE TABLE IF NOT EXISTS kline_day (
    code TEXT NOT NULL,
    date TEXT NOT NULL,
    open REAL,
    high REAL,
    low REAL,
    close REAL,
    volume REAL,
    amount REAL,
    last REAL,
    PRIMARY KEY (code, date)
);
```

## Python 脚本

```python
import requests
import sqlite3
from datetime import datetime, timedelta

BASE_URL = "http://127.0.0.1:8080"
DB_PATH = "kline.db"

conn = sqlite3.connect(DB_PATH)
conn.execute("PRAGMA journal_mode=WAL")


def get_last_date(code: str) -> str | None:
    cur = conn.execute(
        "SELECT date FROM kline_day WHERE code=? ORDER BY date DESC LIMIT 1",
        (code,),
    )
    row = cur.fetchone()
    return row[0] if row else None


def normalize_row(code: str, item: dict) -> tuple:
    factor = 1000.0  # 接口价格单位为厘
    return (
        code,
        item["Time"][:10],  # YYYY-MM-DD
        item["Open"] / factor,
        item["High"] / factor,
        item["Low"] / factor,
        item["Close"] / factor,
        item["Volume"],
        item.get("Amount", 0) / factor,
        item.get("Last", 0) / factor,
    )


def upsert_rows(code: str, rows: list[dict]) -> None:
    with conn:
        conn.executemany(
            """
            INSERT OR REPLACE INTO kline_day
            (code, date, open, high, low, close, volume, amount, last)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (normalize_row(code, item) for item in rows),
        )


def initial_load(code: str, ktype: str = "day") -> None:
    resp = requests.get(
        f"{BASE_URL}/api/kline-all/tdx",
        params={"code": code, "type": ktype, "limit": 0},
        timeout=25,
    )
    data = resp.json()
    if data["code"] != 0:
        raise RuntimeError(data["message"])
    upsert_rows(code, data["data"]["list"])


def fetch_incremental(code: str, last_date: str) -> None:
    start_dt = datetime.strptime(last_date, "%Y-%m-%d") + timedelta(days=1)
    end_dt = datetime.now()
    if start_dt > end_dt:
        return

    resp = requests.get(
        f"{BASE_URL}/api/kline-history",
        params={
            "code": code,
            "type": "day",
            "start_date": start_dt.strftime("%Y%m%d"),
            "end_date": end_dt.strftime("%Y%m%d"),
            "limit": 800,
        },
        timeout=10,
    )
    data = resp.json()
    if data["code"] != 0:
        raise RuntimeError(data["message"])
    rows = data["data"]["List"]
    if rows:
        upsert_rows(code, rows)


def sync_kline(code: str, ktype: str = "day") -> None:
    last = get_last_date(code)
    if last is None:
        initial_load(code, ktype)
    else:
        fetch_incremental(code, last)


if __name__ == "__main__":
    for stock_code in ["000001", "600519"]:
        sync_kline(stock_code)
```

## 说明

- 首次运行调用 `/api/kline-all/tdx` 获取全量历史；之后用 `/api/kline-history` 依赖数据库当前最大日期补齐增量。
- 表中列 `volume`、`amount` 直接保存原始数值（成交量为手，成交额单位为厘）；可在业务层做转换或聚合。
- 若一次增量超过 800 条，可以按时间区间拆分请求；也可适当调大 `limit` 与 `end_date`。
- 可通过定时任务或调度器周期执行 `sync_kline()`，实现自动更新。

---

如需回溯旧版本，请在部署前备份数据库与静态资源；对旧客户端请同步升级解析逻辑。***

